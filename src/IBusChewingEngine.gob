requires 2.0.0

%alltop{
/*
 * Copyright © 2008  Red Hat, Inc. All rights reserved.
 * Copyright © 2008  Ding-Yi Chen <dchen at redhat dot com>
 *
 * This file is part of the libUnihan Project.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA  02111-1307  USA
 */ 
#include <libintl.h>
#include <ibus.h>
#include <chewing.h>
#include <string.h>
#include <stdio.h>
#define GETTEXT_PACKAGE "gtk20"
#include <glib/gi18n.h>
%}


%{
const int selKeys_default[10]={'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};


/*============================================
 * Supporting functions
 */

static IBusText** kbTypes_to_iBusTexts(){
    IBusText **kbTypeTexts=g_new(IBusText *,10+1);
    int i=0;
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Default"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Hsu"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("IBM"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Gin-Yieh"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("ETen"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("ETen 26-keys"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Dvroak"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Dvroak Hsu"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Dachen CP26"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Han-Yu"));
    kbTypeTexts[i]=NULL;
    return kbTypeTexts;
}

static gunichar *preedit_string_make(ChewingContext *context, 
        glong *zhuyin_item_written_ptr,  glong *item_written_ptr){
    glong chiSymbol_item_written=0;
    gchar *str_ptr=chewing_buffer_String(context);
    gunichar *chiSymbolBuf=g_utf8_to_ucs4_fast(str_ptr,-1, &chiSymbol_item_written);
    g_free(str_ptr);

    int chiSymbolCursor = chewing_cursor_Current(context);
    str_ptr=chewing_zuin_String(context,NULL);
    gunichar *zhuyinBuf=g_utf8_to_ucs4_fast(str_ptr,-1, zhuyin_item_written_ptr);
    g_free(str_ptr);

    glong i;
    *item_written_ptr=chiSymbol_item_written+ *zhuyin_item_written_ptr;
    gunichar *preeditBuf=g_new(gunichar, *item_written_ptr+1);
    glong j=0;
    for (i=0;i<*item_written_ptr;i++){
        if (i<chiSymbolCursor){
            preeditBuf[i]=chiSymbolBuf[i];
        }else if (j<*zhuyin_item_written_ptr){
            /* Inserting zhuyinBuf */
            preeditBuf[i]=zhuyinBuf[j++];
        }else{
            /* Append rest zhuyinBuf */
            preeditBuf[i]=chiSymbolBuf[i- *zhuyin_item_written_ptr];
        }
    }
    preeditBuf[i]='\0';
    g_free(chiSymbolBuf);
    g_free(zhuyinBuf);
    return preeditBuf;
}

%}

enum CHEWING_UI_PROP{
    CHI_ENG,
    ALNUM_SIZE,
    KBTYPE,
} Chewing:Ui:Prop;


class IBus:Chewing:Engine from IBus:Engine{
    public ChewingContext *context=NULL
	destroywith chewing_delete;
    public gboolean registered=FALSE;
    public gboolean candidateSelecting=TRUE;

    public IBusLookupTable *table={ibus_lookup_table_new(8,0,FALSE,TRUE)}
	destroy {
	    if (VAR) {
		ibus_lookup_table_clear(VAR);
		g_array_free(VAR->candidates,TRUE);
		g_free(VAR);
	    }
	};
    public IBusProperty    *chieng_prop={
        ibus_property_new(
		"chewing_chieng_prop",PROP_TYPE_NORMAL, SELF_GET_CLASS(self)->chieng_prop_label_chi,
                NULL, NULL, TRUE, 
                TRUE, 0, NULL)
    };
    public IBusProperty    *alnumSize_prop={
        ibus_property_new(
		"chewing_alnumSize_prop",PROP_TYPE_NORMAL, SELF_GET_CLASS(self)->alnumSize_prop_label_half,
            NULL, NULL, TRUE, 
	    TRUE, 0, NULL);
    };
    public IBusProperty    *kbType_prop={
        ibus_property_new(
		"chewing_kbType_prop",PROP_TYPE_NORMAL, SELF_GET_CLASS(self)->kbType_prop_labels[0],
                NULL, NULL, TRUE, 
                TRUE, 0, NULL);
    };
    public IBusPropList    *prop_list={ibus_prop_list_new()};

    classwide IBusText *chieng_prop_label_chi={ibus_text_new_from_static_string(_("Chi"))};
    classwide IBusText *chieng_prop_label_eng={ibus_text_new_from_static_string(_("Eng"))};

    classwide IBusText *alnumSize_prop_label_full={ibus_text_new_from_static_string(_("Full"))};
    classwide IBusText *alnumSize_prop_label_half={ibus_text_new_from_static_string(_("Half"))};

    classwide IBusText **kbType_prop_labels={kbTypes_to_iBusTexts()};

    init (self) {
          /* initialize the object here */

	chewing_Init("/usr/share/chewing","/tmp");

	self->context=chewing_new();
	chewing_set_candPerPage(self->context,18);
	chewing_set_maxChiSymbolLen(self->context,16);
	chewing_set_addPhraseDirection(self->context,0);
	chewing_set_spaceAsSelection(self->context,1);
	chewing_set_KBType(self->context,0);

	chewing_set_selKey(self->context,(int *) selKeys_default,10);
        chewing_set_ChiEngMode(self->context,CHINESE_MODE);

	/* init properties */
	ibus_prop_list_append(self->prop_list,self->chieng_prop);
	ibus_prop_list_append(self->prop_list,self->alnumSize_prop);
	ibus_prop_list_append(self->prop_list,self->kbType_prop);

	ibus_lookup_table_clear(self->table);
	g_debug("***init -1\n");

    }

//    public IBusChewingEngine *new (void) {
//	  return GET_NEW;
//    }


    protected void refresh_preedit(self){
        glong zhuyin_item_written, item_written;
        gunichar *preeditBuf=preedit_string_make(self->context, &zhuyin_item_written, &item_written);
        IBusText *iText=ibus_text_new_from_ucs4(preeditBuf);
	int chiSymbolCursor = chewing_cursor_Current(self->context);
        ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_FOREGROUND, 0x00ffffff, 
                chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);
        ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_BACKGROUND, 0x00000000,
                chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);
        ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_UNDERLINE, IBUS_ATTR_UNDERLINE_SINGLE,
                0, -1);
	ibus_engine_update_preedit_text (IBUS_ENGINE(self),iText, chiSymbolCursor, TRUE);
        g_object_unref (iText);

    }

    protected gboolean commit(self){
        /* commit string */
	gunichar *text=NULL;
	IBusText *iText=NULL;
        glong item_written;

	g_debug("***commit 1\n");
	if (chewing_commit_Check(self->context)){
	    text=g_utf8_to_ucs4_fast(chewing_commit_String(self->context),-1, &item_written);
	    iText=ibus_text_new_from_ucs4(text);
	    g_debug("***commit 3\n");
	    ibus_engine_commit_text(IBUS_ENGINE(self),iText);
	    g_debug("***commit 4\n");
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	    g_free(text);
	    g_object_unref(iText);
	}
	self_refresh_preedit(self);

	/* Update lookup table */
	ibus_lookup_table_clear(self->table);
	int choicePerPage=chewing_cand_ChoicePerPage(self->context);
//	int cand_toSkip=chewing_cand_CurrentPage(self->context)*choicePerPage;
	int i=0;
	char *candidate=NULL;
	iText=NULL;

	if (chewing_cand_TotalChoice(self->context) >0){
	    g_debug("***commit 5\n");
	    chewing_cand_Enumerate(self->context);
	    for(i=0;i<choicePerPage;i++){
		if (chewing_cand_hasNext(self->context)){
		    candidate=chewing_cand_String(self->context);
		    iText=ibus_text_new_from_string (candidate);
		    ibus_lookup_table_append_candidate(self->table,iText);
		    g_free(candidate);
                    g_object_unref (iText);
                }else{
		    break;
		}
	    }
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,TRUE);
	}else{
	    g_debug("***commit 6\n");
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	}
	if (self->candidateSelecting){
	    g_debug("***commit 7\n");
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,TRUE);
	    ibus_engine_show_lookup_table(IBUS_ENGINE(self));
	}else{
	    g_debug("***commit 8\n");
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	}

        /* update aux string */
	text=g_utf8_to_ucs4_fast(chewing_aux_String(self->context),-1,&item_written);
	if (item_written>=0){
            iText=ibus_text_new_from_ucs4 (text);
	    ibus_engine_update_auxiliary_text(IBUS_ENGINE(self),iText,TRUE);
            g_object_unref (iText);
	    ibus_engine_show_auxiliary_text(IBUS_ENGINE(self));
	}
        if (text){
	    ibus_engine_hide_auxiliary_text(IBUS_ENGINE(self));
	    g_free(text);
        }

        if (chewing_keystroke_CheckAbsorb(self->context))
            return TRUE;
        if (chewing_keystroke_CheckIgnore(self->context))
            return FALSE;
        return TRUE;
    }

    /*============================================
     * Overridden Parent (IBusEngine) methods
     */

    override (IBus:Engine) void
    reset(IBus:Engine *self){
	Self *selfObj=SELF(self);
	ibus_lookup_table_clear(selfObj->table);
	chewing_Reset(selfObj->context);
	self_commit(selfObj);
	g_debug("***reset -1\n");
    }

    override (IBus:Engine) gboolean
    process_key_event(IBus:Engine *self, guint  keyval,  guint  modifiers){
	Self *selfObj=SELF(self);
	if (modifiers & IBUS_RELEASE_MASK)
	    return FALSE;
	g_debug("***process_key_event 1\n");
	guint state= modifiers & (IBUS_SHIFT_MASK | IBUS_CONTROL_MASK | IBUS_MOD1_MASK);
	if (state==0){
	    g_debug("***process_key_event 2\n");
	    switch (keyval){
		case IBUS_Return:
		case IBUS_KP_Enter:
		    chewing_handle_Enter(selfObj->context);
		    break;
		case IBUS_Escape:
		    chewing_handle_Esc(selfObj->context);
		    break;
		case IBUS_BackSpace:
		    chewing_handle_Backspace(selfObj->context);
		    break;
		case IBUS_Delete:
		case IBUS_KP_Delete:
		    chewing_handle_Del(selfObj->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_Space(selfObj->context);
		    break;
		case IBUS_Page_Up:
		case IBUS_KP_Page_Up:
		    IBUS_ENGINE_GET_CLASS(self)->page_up(self);
		    break;
		case IBUS_Page_Down:
		case IBUS_KP_Page_Down:
		    IBUS_ENGINE_GET_CLASS(self)->page_down(self);
		    break;
		case IBUS_Up:
		case IBUS_KP_Up:
		    IBUS_ENGINE_GET_CLASS(self)->cursor_up(self);
		    break;
		case IBUS_Down:
		case IBUS_KP_Down:
		    IBUS_ENGINE_GET_CLASS(self)->cursor_down(self);
		    break;
		case IBUS_Left:
		case IBUS_KP_Left:
		    chewing_handle_Left(selfObj->context);
		    break;
		case IBUS_Right:
		case IBUS_KP_Right:
		    chewing_handle_Left(selfObj->context);
		    break;
		case IBUS_Home:
		case IBUS_KP_Home:
		    chewing_handle_Home(selfObj->context);
		    break;
		case IBUS_End:
		case IBUS_KP_End:
		    chewing_handle_End(selfObj->context);
		    break;
		case IBUS_Tab:
		    chewing_handle_Tab(selfObj->context);
		    break;
		case IBUS_Caps_Lock:
		    chewing_handle_Capslock(selfObj->context);
		    self_refresh_property(selfObj,"chewing_chieng_prop",0);
		    break;
		default:
		    chewing_handle_Default(selfObj->context,keyval);
		    selfObj->candidateSelecting=FALSE;
		    break;
	    }
	}else if (state==IBUS_SHIFT_MASK){
	    g_debug("***process_key_event 10\n");
	    switch(keyval){
		case IBUS_Shift_L:
		    chewing_handle_ShiftLeft(selfObj->context);
		    break;
		case IBUS_Shift_R:
		    chewing_handle_ShiftRight(selfObj->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_ShiftSpace(selfObj->context);
		    self_refresh_property(selfObj,"chewing_alnumSize_prop",0);
		    break;
		default:
		    chewing_handle_Default(selfObj->context,keyval);
		    break;
	    }
	}else if (state==IBUS_CONTROL_MASK){
	    g_debug("***process_key_event 20\n");
	    if (keyval>=IBUS_0 && keyval<=IBUS_9){
		g_debug("***process_key_event 21\n");
		chewing_handle_CtrlNum(selfObj->context,keyval);

	    }else{
		g_debug("***process_key_event 22\n");
		return FALSE;
	    }

	}else{
	    g_debug("***process_key_event 30\n");
	    return FALSE;
	}
	g_debug("***process_key_event -1\n");
	return self_commit(selfObj);
    }


    override (IBus:Engine) void 
    page_up(IBus:Engine *self){
        Self *selfObj=SELF(self);
	chewing_handle_PageUp(selfObj->context);
	self_commit(selfObj);
    }


    override (IBus:Engine) void
    page_down(IBus:Engine *self){
        Self *selfObj=SELF(self);
	chewing_handle_PageDown(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    cursor_up(IBus:Engine *self){
        Self *selfObj=SELF(self);
	chewing_handle_Up(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    cursor_down(IBus:Engine *self){
	g_debug("*** cursor_down 1\n");
	Self *selfObj=SELF(self);
	chewing_handle_Down(selfObj->context);
	selfObj->candidateSelecting=TRUE;
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    enable(IBus:Engine  *self){
	g_debug("*** enable 1\n");
	Self *selfObj=SELF(self);
    }



    override (IBus:Engine) void
    focus_in(IBus:Engine *self){
	g_debug("*** focus_in 1\n");
	Self *selfObj=SELF(self);
	ibus_engine_register_properties(self,selfObj->prop_list);
	//	self_refresh_properties(selfObj);
	self_refresh_preedit(selfObj);
    }

    override (IBus:Engine) void
    focus_out(IBus:Engine *self){
	;
    }


    protected void refresh_property(self,const gchar  *prop_name, gint  prop_state){
	g_debug("*** refresh_propert(-,%s,%d) 1\n",prop_name,prop_state);
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    if (chewing_get_ChiEngMode(self->context)){
		/* Chinese  */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_chi);
	    }else{
		/* English */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_eng);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->chieng_prop);
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    if (chewing_get_ShapeMode(self->context)){
		/* Full-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_full);
	    }else{
		/* Half-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_half);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->alnumSize_prop);
	}else if (strcmp(prop_name,"chewing_kbType_prop")==0){
	    int kbType=chewing_get_KBType( self->context);
	    ibus_property_set_label(self->kbType_prop,SELF_GET_CLASS(self)->kbType_prop_labels[kbType]);
	    ibus_engine_update_property(IBUS_ENGINE(self),self->kbType_prop);
	}


    }

    override (IBus:Engine) void
    property_activate(IBus:Engine *self, const gchar  *prop_name, guint  prop_state){
	Self *selfObj=SELF(self);
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    if (chewing_get_ChiEngMode(selfObj->context)){
		/* Chinese -> English */
		chewing_set_ChiEngMode(selfObj->context, 0);
	    }else{
		/* English -> Chinese */
		chewing_set_ChiEngMode(selfObj->context, CHINESE_MODE);
	    }
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    if (chewing_get_ShapeMode(selfObj->context)){
		/* Full -> Half */
		chewing_set_ShapeMode(selfObj->context, HALFSHAPE_MODE);
	    }else{
		/* Half -> Full */
		chewing_set_ChiEngMode(selfObj->context, FULLSHAPE_MODE);
	    }
	}else if (strcmp(prop_name,"chewing_kbType_prop")==0){
	    guint kbType=chewing_get_KBType( selfObj->context);
	    if (chewing_set_KBType(selfObj->context,++kbType)){
	        /* Unsuccessfully, set to default */
	       chewing_set_KBType(selfObj->context,0);
	    }
	}
	self_refresh_property(selfObj,prop_name,prop_state);
    }

}
