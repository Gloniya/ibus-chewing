requires 2.0.0

%alltop{
/*
 * Copyright © 2009  Red Hat, Inc. All rights reserved.
 * Copyright © 2009  Ding-Yi Chen <dchen at redhat.com>
 *
 * This file is part of the ibus-chewing Project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */ 
#include <stdlib.h>
#include <libintl.h>
#include <ibus.h>
#include <chewing.h>
#include <string.h>
#include <stdio.h>
#define GETTEXT_PACKAGE "gtk20"
#include <glib/gi18n.h>
#include <gtk/gtk.h>
#include <gconf/gconf.h>
#include <gconf/gconf-client.h>
#include <X11/extensions/XTest.h>
#include <X11/Xlib.h>
%}


enum CHEWING_KBTYPE{
    INVALID=-1,
    DEFAULT,
    HSU,
    IBM,
    GIN_YIEH,
    ETEN,
    ETEN26,
    DVORAK,
    DVORAK_HSU,
    DACHEN_CP26,
    HAN_YU
} Chewing:KbType;

enum CHEWING_MODIFIER_SYNC{
    NONE,
    FROM_KEYBOARD,
    FROM_IM
} Chewing:Modifier:Sync;

%headertop{
#include "maker-dialog.h"
#define GCONF_KEY_PREFIX "/desktop/ibus/engine/Chewing/"
%}

%{
extern gboolean ibus_chewing_verbose;
#ifndef DEBUG_LEVEL
#define DEBUG_LEVEL 3
#endif

#define G_DEBUG_MSG(level, msg, args...) if (ibus_chewing_verbose) if (level<=DEBUG_LEVEL) g_debug(msg, ##args)
#include "IBusChewingEngine-def.c"

%}


class IBus:Chewing:Engine from IBus:Engine{
    public ChewingContext *context=NULL
	destroywith chewing_delete;

    public Chewing:Modifier:Sync sync_CapsLock_local=CHEWING_MODIFIER_SYNC_FROM_KEYBOARD;

    public GtkWidget *setting_dialog={
	GTK_WIDGET(maker_dialog_new_full(_("Setting"),3,page_labels,1,button_labels,button_responses))};

    /* Number of event to be skipped */
    private guint event_skipCount=0;

    protected gint selKeys[MAX_SELKEY];

    protected IBusLookupTable *table=NULL
	destroy {
	    if (VAR) {
		ibus_lookup_table_clear(VAR);
		g_array_free(VAR->candidates,TRUE);
		g_free(VAR);
	    }
	};
    public IBusProperty    *chieng_prop={
        ibus_property_new("chewing_chieng_prop",PROP_TYPE_NORMAL, 
		SELF_GET_CLASS(self)->chieng_prop_label_chi,
		NULL, NULL, TRUE, TRUE, 
		PROP_STATE_UNCHECKED, NULL)
    };
    public IBusProperty    *alnumSize_prop={
        ibus_property_new("chewing_alnumSize_prop",PROP_TYPE_NORMAL,
	       	SELF_GET_CLASS(self)->alnumSize_prop_label_half,
	      	NULL, NULL, TRUE, TRUE, 
		PROP_STATE_UNCHECKED, NULL);
    };

    public IBusProperty    *settings_prop={
	ibus_property_new("chewing_settings_prop",PROP_TYPE_NORMAL,
	       	SELF_GET_CLASS(self)->settings_prop_label,
		PKGDATADIR "/icons/settings.png", NULL, TRUE, TRUE, 
		PROP_STATE_UNCHECKED, NULL);
    };


    public IBusPropList   *prop_list={ibus_prop_list_new()};

    public IBusConfig *config=NULL;

    private Display *pDisplay = {XOpenDisplay( NULL )}
          destroywith XCloseDisplay;

    classwide GConfClient *gConfClient={gconf_client_get_default ()};

    classwide IBusText *chieng_prop_label_chi={ibus_text_new_from_static_string(_("Chi"))};
    classwide IBusText *chieng_prop_label_eng={ibus_text_new_from_static_string(_("Eng"))};

    classwide IBusText *alnumSize_prop_label_full={ibus_text_new_from_static_string(_("Full"))};
    classwide IBusText *alnumSize_prop_label_half={ibus_text_new_from_static_string(_("Half"))};

    classwide IBusText *settings_prop_label={ibus_text_new_from_static_string(_("Settings"))};

    init (self) {
          /* initialize the object here */
	G_DEBUG_MSG(2,"*** init()");

	chewing_Init(CHEWING_DATADIR, "/tmp");

	self->context=chewing_new();
	chewing_set_ChiEngMode(self->context,CHINESE_MODE);

	/* init properties */
	ibus_prop_list_append(self->prop_list,self->chieng_prop);
	ibus_prop_list_append(self->prop_list,self->alnumSize_prop);
	ibus_prop_list_append(self->prop_list,self->settings_prop);
	self_context_load_parameters(self);

	self->table=ibus_lookup_table_new(chewing_get_candPerPage(self->context),0,FALSE,TRUE);
	ibus_lookup_table_clear(self->table);
    }

    private void context_load_parameters(self){
	G_DEBUG_MSG(3,"*** context_load_parameters()");
	int i;
	gchar confKey[200];

	int confKeyPrefix_len=strlen(GCONF_KEY_PREFIX);
	GError *err=NULL;
	g_strlcpy(confKey,GCONF_KEY_PREFIX,200);
	gboolean staticString;
 
	for (i=0; propSpecs[i].valueType!=G_TYPE_INVALID;i++){
	    G_DEBUG_MSG(3,"*** context_load_parameters(), i=%d",i);
	    confKey[confKeyPrefix_len]='\0';
	    g_strlcat(confKey,propSpecs[i].key,200);
	    staticString=FALSE;

	    gchar *valueStr=gconf_client_get_string(SELF_GET_CLASS(self)->gConfClient, confKey, &err);
	    if (err){
		g_warning("Warning: cannot load confKey %s because %s %s %s",
			confKey,
			err->message,
			(propSpecs[i].defaultValue)? _(" Use default value:") : _(" No default value, skipped.") ,
			(propSpecs[i].defaultValue)? propSpecs[i].defaultValue : ""
			);
		staticString=TRUE;
		g_free(valueStr);
		g_error_free (err);
		if (propSpecs[i].defaultValue){
		    valueStr=propSpecs[i].defaultValue;
		}else{
		    continue;
		}
	    }

	    /* Add property to dialog */
	    maker_dialog_add_property(MAKER_DIALOG(self->setting_dialog),&propSpecs[i],valueStr,self);
	    maker_dialog_apply_widget_value(MAKER_DIALOG(self->setting_dialog),propSpecs[i].key);
	    if (!staticString)
		g_free(valueStr);
	}
    }

    protected gboolean commit(self){
	/* commit string */
	G_DEBUG_MSG(2,"*** commit()");

	gunichar *text=NULL;
	IBusText *iText=NULL;
	glong item_written;

	if (chewing_commit_Check(self->context)){
	    gchar *commit_string=chewing_commit_String(self->context);
	    text=g_utf8_to_ucs4_fast(commit_string,-1, &item_written);
	    iText=ibus_text_new_from_ucs4(text);
	    ibus_engine_commit_text(IBUS_ENGINE(self),iText);
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	    g_free(text);
	    g_free(commit_string);
	    g_object_unref(iText);
	}
	self_refresh_preedit(self);

	/* Update lookup table */
	ibus_lookup_table_clear(self->table);
	int choicePerPage=chewing_cand_ChoicePerPage(self->context);
	int i=0;
	char *candidate=NULL;
	iText=NULL;

	if (chewing_cand_TotalChoice(self->context) >0){
	    chewing_cand_Enumerate(self->context);
	    for(i=0;i<choicePerPage;i++){
		if (chewing_cand_hasNext(self->context)){
		    candidate=chewing_cand_String(self->context);
		    iText=ibus_text_new_from_string (candidate);
		    ibus_lookup_table_append_candidate(self->table,iText);
		    g_free(candidate);
		    g_object_unref (iText);
		}else{
		    break;
		}
	    }
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,TRUE);
	    ibus_engine_show_lookup_table(IBUS_ENGINE(self));
	}else{
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	}

	/* update aux string */
	gchar *aux_string=chewing_aux_String(self->context);
	text=g_utf8_to_ucs4_fast(aux_string,-1,&item_written);
	if (item_written>0){
	    iText=ibus_text_new_from_ucs4 (text);
	    ibus_engine_update_auxiliary_text(IBUS_ENGINE(self),iText,TRUE);
	    g_object_unref (iText);
	    ibus_engine_show_auxiliary_text(IBUS_ENGINE(self));
	}else{
	    ibus_engine_hide_auxiliary_text(IBUS_ENGINE(self));
	}

	g_free(aux_string);
	g_free(text);

	if (chewing_keystroke_CheckAbsorb(self->context))
	    return TRUE;
	if (chewing_keystroke_CheckIgnore(self->context))
	    return FALSE;
	return TRUE;
    }

    protected void refresh_preedit(self){
	glong zhuyin_item_written, item_written;
	gunichar *preeditBuf=preedit_string_make(self->context, &zhuyin_item_written, &item_written);
	IBusText *iText=ibus_text_new_from_ucs4(preeditBuf);
	int chiSymbolCursor = chewing_cursor_Current(self->context);
	ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_FOREGROUND, 0x00ffffff, 
		chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);
	ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_BACKGROUND, 0x00000000,
		chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);
	ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_UNDERLINE, IBUS_ATTR_UNDERLINE_SINGLE,
		0, -1);
	ibus_engine_update_preedit_text (IBUS_ENGINE(self),iText, chiSymbolCursor, TRUE);
	g_object_unref (iText);
    }

    protected void refresh_property(self,const gchar  *prop_name){
	G_DEBUG_MSG(2,"*** refresh_property(%s)",prop_name);
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    if (chewing_get_ChiEngMode(self->context)){
		/* Chinese  */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_chi);
	    }else{
		/* English */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_eng);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->chieng_prop);
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    if (chewing_get_ShapeMode(self->context)){
		/* Full-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_full);
	    }else{
		/* Half-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_half);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->alnumSize_prop);
	}
    }

    /**
     * refresh_prop_list:
     * @self: this instances.
     *
     * Refresh the property list (language bar).
     */
    public void refresh_property_list(self){
	G_DEBUG_MSG(1,"*** refresh_property_list()");
	self_refresh_property(self,"chewing_chieng_prop");

	self_refresh_property(self,"chewing_alnumSize_prop");

	self_refresh_property(self,"chewing_settings_prop");
	ibus_engine_register_properties(IBUS_ENGINE(self),self->prop_list);
    }

    /**
     * save_config:
     * @self: this instances.
     * @key_suffix: key to be set.
     * @configValue: Key value.
     * @returns: TRUE if successful, FALSE otherwise.
     *
     * Set and save the property value.
     */
    public gboolean save_config(self, const gchar *key_suffix, gpointer configValue){
	G_DEBUG_MSG(1,"*** save_config(%s,-)",key_suffix);
	int index=parameter_get_index(key_suffix);
	GValue gValue={0};
	g_assert(index>=0);
	switch(parameters[index].type){
	    case GCONF_VALUE_STRING:
		g_value_init(&gValue,G_TYPE_STRING);
		g_value_set_static_string (&gValue,(gchar *) configValue);
		G_DEBUG_MSG(4,"*** save_config(-,%s,%s) str",key_suffix,(gchar *) configValue);
		break;
	    case GCONF_VALUE_INT:
		g_value_init(&gValue,G_TYPE_INT);
		gint *int_p=(gint *) configValue;
		g_value_set_int (&gValue, *int_p);
		G_DEBUG_MSG(4,"*** save_config(-,%s,%d) int",key_suffix,*int_p);
		break;
	    case GCONF_VALUE_BOOL:
		g_value_init(&gValue,G_TYPE_BOOLEAN);
		gboolean *bool_p=(gboolean *) configValue;
		g_value_set_boolean (&gValue, *bool_p);
		G_DEBUG_MSG(4,"*** save_config(-,%s,%d) int",key_suffix,*bool_p);
		break;
	    default:
		g_error("Invalid conf value type!");
		break;
	}
	return ibus_config_set_value (self->config,"engine/Chewing",key_suffix,&gValue);
    }

    protected void set_selKeys_string(self,const gchar* selKeys_str){
	int j;
	int len_min= MIN(strlen(selKeys_str), MAX_SELKEY);
	for (j=0;j< len_min;j++){
	    self->selKeys[j]=(int) selKeys_str[j];
	}
	chewing_set_selKey(self->context, self->selKeys,len_min);
    }

    private IBusProperty* get_iBusProperty(self, const gchar *prop_name){
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    return self->chieng_prop;
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    return self->alnumSize_prop;
	}else if (strcmp(prop_name,"chewing_settings_prop")==0){
	    return self->settings_prop;
	}
	G_DEBUG_MSG(2,"*** get_iBusProperty(%s): NULL is returned",prop_name);
	return NULL;
    }

    /*============================================
     * Overridden Parent (IBusEngine) methods
     */

    override (IBus:Engine) void
    reset(IBus:Engine *self){
	G_DEBUG_MSG(2,"*** reset 1");
	Self *selfObj=SELF(self);
	ibus_lookup_table_clear(selfObj->table);
	chewing_Reset(selfObj->context);
	ibus_engine_hide_auxiliary_text(IBUS_ENGINE(self));
	self_commit(selfObj);
    }


    override (IBus:Engine) gboolean
    process_key_event(IBus:Engine *self, guint  keyval,  guint  modifiers){
	Self *selfObj=SELF(self);
	gboolean result=TRUE;
	if (modifiers & IBUS_RELEASE_MASK){
	    /* Skip release event */
	    return TRUE;
	}

	
	G_DEBUG_MSG(3,"*** process_key_event(-, %u(%c), %u) ... proceed.",keyval, keyval, modifiers);
	guint state= modifiers & (IBUS_SHIFT_MASK | IBUS_CONTROL_MASK | IBUS_MOD1_MASK);
	if (state==0){
	    switch (keyval){
		case IBUS_Return:
		case IBUS_KP_Enter:
		    chewing_handle_Enter(selfObj->context);
		    break;
		case IBUS_Escape:
		    chewing_handle_Esc(selfObj->context);
		    break;
		case IBUS_BackSpace:
		    chewing_handle_Backspace(selfObj->context);
		    break;
		case IBUS_Delete:
		case IBUS_KP_Delete:
		    chewing_handle_Del(selfObj->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_Space(selfObj->context);
		    break;
		case IBUS_Page_Up:
		case IBUS_KP_Page_Up:
		    IBUS_ENGINE_GET_CLASS(self)->page_up(self);
		    break;
		case IBUS_Page_Down:
		case IBUS_KP_Page_Down:
		    IBUS_ENGINE_GET_CLASS(self)->page_down(self);
		    break;
		case IBUS_Up:
		case IBUS_KP_Up:
		    IBUS_ENGINE_GET_CLASS(self)->cursor_up(self);
		    break;
		case IBUS_Down:
		case IBUS_KP_Down:
		    IBUS_ENGINE_GET_CLASS(self)->cursor_down(self);
		    break;
		case IBUS_Left:
		case IBUS_KP_Left:
		    chewing_handle_Left(selfObj->context);
		    break;
		case IBUS_Right:
		case IBUS_KP_Right:
		    chewing_handle_Left(selfObj->context);
		    break;
		case IBUS_Home:
		case IBUS_KP_Home:
		    chewing_handle_Home(selfObj->context);
		    break;
		case IBUS_End:
		case IBUS_KP_End:
		    chewing_handle_End(selfObj->context);
		    break;
		case IBUS_Tab:
		    chewing_handle_Tab(selfObj->context);
		    break;
		case IBUS_Caps_Lock:
		    chewing_handle_Capslock(selfObj->context);
		    self_refresh_property(selfObj,"chewing_chieng_prop");
		    break;
		default:
		    chewing_handle_Default(selfObj->context,keyval);
		    break;
	    }
	}else if (state==IBUS_SHIFT_MASK){
	    switch(keyval){
		case IBUS_Shift_L:
		    chewing_handle_ShiftLeft(selfObj->context);
		    break;
		case IBUS_Shift_R:
		    chewing_handle_ShiftRight(selfObj->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_ShiftSpace(selfObj->context);
		    chewing_set_ShapeMode(selfObj->context, !chewing_get_ShapeMode(selfObj->context));
		    self_refresh_property(selfObj,"chewing_alnumSize_prop");
		    break;
		default:
		    chewing_handle_Default(selfObj->context,keyval);
		    break;
	    }
	}else if (state==IBUS_CONTROL_MASK){
	    if (keyval>=IBUS_0 && keyval<=IBUS_9){
		chewing_handle_CtrlNum(selfObj->context,keyval);
	    }else if (keyval==IBUS_v || keyval==IBUS_V){
		chewing_handle_Right(selfObj->context);
	    }else{
		result=FALSE;
	    }

	}else{
	    result=FALSE;
	}
	if (!result){
	    return FALSE;
	}
	return self_commit(selfObj);
    }


    override (IBus:Engine) void 
    page_up(IBus:Engine *self){
	Self *selfObj=SELF(self);
	chewing_handle_PageUp(selfObj->context);
	self_commit(selfObj);
    }


    override (IBus:Engine) void
    page_down(IBus:Engine *self){
	Self *selfObj=SELF(self);
	chewing_handle_PageDown(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    cursor_up(IBus:Engine *self){
	Self *selfObj=SELF(self);
	chewing_handle_Up(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    cursor_down(IBus:Engine *self){
	Self *selfObj=SELF(self);
	chewing_handle_Down(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    enable(IBus:Engine  *self){
	G_DEBUG_MSG(2,"*** enable");
	Self *selfObj=SELF(self);

	if (!selfObj->config){
	    /* connections_list is not avail in init, so we put it here */
	    GList  *connections_list=ibus_service_get_connections(IBUS_SERVICE(self));
	    g_assert(connections_list);
	    g_assert(connections_list->data);
	    IBusConnection *iConnection=(IBusConnection *) connections_list->data;
	    selfObj->config=ibus_config_new(iConnection);
	}

    }

    override (IBus:Engine) void
    disable(IBus:Engine  *self){
	G_DEBUG_MSG(2,"*** disable");
    }

    override (IBus:Engine) void
    focus_in(IBus:Engine *self){
	G_DEBUG_MSG(2,"*** focus_in");
	Self *selfObj=SELF(self);
	
	/* Sync Caps_Lock and ChiEngMode */
	guint modifiers=keyModifier_get(selfObj->_priv->pDisplay);
	gint caps_is_lock=(modifiers & IBUS_LOCK_MASK)!=0;
	G_DEBUG_MSG(2,"focus_in(): ChiEng=%d IBUS_LOCK=%d",
		chewing_get_ChiEngMode(selfObj->context),caps_is_lock);
	if (chewing_get_ChiEngMode(selfObj->context)==caps_is_lock){
	    /* Caps_lock and ChiEngMode does not agree each other */
	    switch(selfObj->sync_CapsLock_local){
		case CHEWING_MODIFIER_SYNC_FROM_KEYBOARD:
		    chewing_set_ChiEngMode(selfObj->context,!caps_is_lock);
		    break;
		case CHEWING_MODIFIER_SYNC_FROM_IM:
		    /* fake event won't go through process_key_event */
		    key_send_fake_event(IBUS_Caps_Lock,selfObj->_priv->pDisplay);
		    break;
		default:
		    g_warning("Caps_lock and ChiEngMode does not agree each other!");
		    break;

	    }
	}
	self_refresh_property_list(selfObj);
	self_refresh_preedit(selfObj);
    }

    override (IBus:Engine) void
    focus_out(IBus:Engine *self){
	G_DEBUG_MSG(2,"*** focus_out 1");
    }

    override (IBus:Engine) void
    property_activate(IBus:Engine *self, const gchar  *prop_name, guint  prop_state){
	G_DEBUG_MSG(2,"*** property_activate(-, %s, %u)", prop_name, prop_state);
	Self *selfObj=SELF(self);
	gboolean needRefresh=TRUE;
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    /* Toggle Chinese <-> English */
	    chewing_set_ChiEngMode(selfObj->context, !chewing_get_ChiEngMode(selfObj->context));
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    /* Toggle Full <-> Half */
	    chewing_set_ShapeMode(selfObj->context, !chewing_get_ShapeMode(selfObj->context));
	}else if (strcmp(prop_name,"chewing_settings_prop")==0){
	    gtk_dialog_run(GTK_DIALOG(selfObj->setting_dialog));
	    gtk_widget_hide(selfObj->setting_dialog);
	    needRefresh=FALSE;
	}else{
	    G_DEBUG_MSG(2,"*** property_activate(-, %s, %u) not recognized",prop_name, prop_state);
	    needRefresh=FALSE;
	}
	if (needRefresh)
	    self_refresh_property(selfObj,prop_name);
    }

    override (IBus:Engine) void
    property_show(IBus:Engine *self, const gchar  *prop_name){
	G_DEBUG_MSG(2,"*** property_show(-, %s)",prop_name);
	Self *selfObj=SELF(self);
	IBusProperty *prop=self_get_iBusProperty(selfObj, prop_name);
	ibus_property_set_visible(prop,TRUE);
	ibus_engine_update_property(self,prop);
    }

    override (IBus:Engine) void
    property_hide(IBus:Engine *self, const gchar  *prop_name){
	G_DEBUG_MSG(2,"*** property_hide(-, %s)",prop_name);
	Self *selfObj=SELF(self);
	IBusProperty *prop=self_get_iBusProperty(selfObj, prop_name);
	ibus_property_set_visible(prop,FALSE);
	ibus_engine_update_property(self,prop);
    }
}
