requires 2.0.0

%alltop{
/*
 * Copyright © 2008  Red Hat, Inc. All rights reserved.
 * Copyright © 2008  Ding-Yi Chen <dchen at redhat dot com>
 *
 * This file is part of the libUnihan Project.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA  02111-1307  USA
 */ 
#include <libintl.h>
#include <ibus.h>
#include <chewing.h>
#include <string.h>
#include <stdio.h>
#define GETTEXT_PACKAGE "gtk20"
#include <glib/gi18n.h>
#include <gconf/gconf-client.h>
%}


enum CHEWING_KBTYPE{
    INVALID=-1,
    DEFAULT,
    HSU,
    IBM,
    GIN_YIEH,
    ETEN,
    ETEN26,
    DVORAK,
    DVORAK_HSU,
    DACHEN_CP26,
    HAN_YU
} Chewing:KbType;

%headertop{
#define GCONF_KEY_PREFIX "/desktop/ibus/engine/Chewing/"
%}

%{
extern gboolean ibus_chewing_verbose;

#define G_DEBUG_MSG(msg, args...) if (ibus_chewing_verbose) g_debug(msg, ##args)
const int selKeys_default[10]={'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};
const char *kbType_ids[]={
    "chewing_kbtype_default",
    "chewing_kbtype_hsu",
    "chewing_kbtype_ibm",
    "chewing_kbtype_gin_yieh",
    "chewing_kbtype_eten",
    "chewing_kbtype_eten26",
    "chewing_kbtype_dvorak",
    "chewing_kbtype_dvorak_hsu",
    "chewing_kbtype_dachen_26",
    "chewing_kbtype_hanyu",
    NULL
};

typedef gint (*ChewingSettingFunc)(ChewingContext *ctx, int mode);

typedef struct{
    GConfValueType type;
    gchar key[30];
    gchar defaultValue[30];
    ChewingSettingFunc func;
} ChewingParameter;

const ChewingParameters parameters[]={
    {GCONF_VALUE_STRING, "KBType","chewing_kbtype_default",chewing_set_KBType},
    {GCONF_VALUE_BOOL, "autoShiftCur","0",chewing_set_autoShiftCur},
    {GCONF_VALUE_BOOL, "addPhraseDirection","0",chewing_set_addPhraseDirection},
    {GCONF_VALUE_INT, "candPerPage","10",chewing_set_candPerPage},
    {GCONF_VALUE_BOOL, "escCleanAllBuf","0",chewing_set_escCleanAllBuf},
    {GCONF_VALUE_INT, "hsuSelKeyType","1",chewing_set_hsuSelKeyType},
    {GCONF_VALUE_INT, "maxChiSymbolLen","16",chewing_set_maxChiSymbolLen},
    {GCONF_VALUE_STRING, "selKeys","1234567890",NULL},
    {GCONF_VALUE_BOOL, "spaceAsSelection","1",spaceAsSelection},
    {GCONF_VALUE_INVALID, "","", NULL, NULL}
};

/*============================================
 * Supporting functions
 */

static IBusText** kbTypes_to_iBusTexts(){
    IBusText **kbTypeTexts=g_new(IBusText *,10+1);
    int i=0;
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Default"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Hsu"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("IBM"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Gin-Yieh"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("ETen"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("ETen 26 keys"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Dvorak"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Dvorak Hsu"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Dachen CP26"));
    kbTypeTexts[i++]=ibus_text_new_from_static_string(_("Hanyu"));
    kbTypeTexts[i]=NULL;
    return kbTypeTexts;
}


static ChewingKbType kbType_id_get_index(const gchar *kbType_id){
    gint i=0;
    for(i=0;kbType_ids[i]!=NULL;i++){
	if (strcmp(kbType_id,kbType_ids[i])==0){
	    return i;
	}
    }
    return CHEWING_KBTYPE_INVALID;
}


static gunichar *preedit_string_make(ChewingContext *context, 
        glong *zhuyin_item_written_ptr,  glong *item_written_ptr){
    glong chiSymbol_item_written=0;
    gchar *str_ptr=chewing_buffer_String(context);
    gunichar *chiSymbolBuf=g_utf8_to_ucs4_fast(str_ptr,-1, &chiSymbol_item_written);
    g_free(str_ptr);

    int chiSymbolCursor = chewing_cursor_Current(context);
    str_ptr=chewing_zuin_String(context,NULL);
    gunichar *zhuyinBuf=g_utf8_to_ucs4_fast(str_ptr,-1, zhuyin_item_written_ptr);
    g_free(str_ptr);

    glong i;
    *item_written_ptr=chiSymbol_item_written+ *zhuyin_item_written_ptr;
    gunichar *preeditBuf=g_new(gunichar, *item_written_ptr+1);
    glong j=0;
    for (i=0;i<*item_written_ptr;i++){
        if (i<chiSymbolCursor){
            preeditBuf[i]=chiSymbolBuf[i];
        }else if (j<*zhuyin_item_written_ptr){
            /* Inserting zhuyinBuf */
            preeditBuf[i]=zhuyinBuf[j++];
        }else{
            /* Append rest zhuyinBuf */
            preeditBuf[i]=chiSymbolBuf[i- *zhuyin_item_written_ptr];
        }
    }
    preeditBuf[i]='\0';
    g_free(chiSymbolBuf);
    g_free(zhuyinBuf);
    return preeditBuf;
}

%}


class IBus:Chewing:Engine from IBus:Engine{
    public ChewingContext *context=NULL
	destroywith chewing_delete;

    public gboolean showSetting=FALSE;

    protected IBusLookupTable *table={ibus_lookup_table_new(8,0,FALSE,TRUE)}
	destroy {
	    if (VAR) {
		ibus_lookup_table_clear(VAR);
		g_array_free(VAR->candidates,TRUE);
		g_free(VAR);
	    }
	};
    public IBusProperty    *chieng_prop={
        ibus_property_new(
		"chewing_chieng_prop",PROP_TYPE_NORMAL, SELF_GET_CLASS(self)->chieng_prop_label_chi,
                NULL, NULL, TRUE, 
                TRUE, 0, NULL)
    };
    public IBusProperty    *alnumSize_prop={
        ibus_property_new(
		"chewing_alnumSize_prop",PROP_TYPE_NORMAL, SELF_GET_CLASS(self)->alnumSize_prop_label_half,
            NULL, NULL, TRUE, 
	    TRUE, 0, NULL);
    };

    public IBusProperty    *settings_prop={
	ibus_property_new(
		"chewing_settings_prop",PROP_TYPE_TOGGLE,
	       	SELF_GET_CLASS(self)->settings_prop_label,
		PKGDATADIR "/icons/settings.png", NULL, TRUE, 
		TRUE, PROP_STATE_UNCHECKED, NULL);
    };

    protected IBusPropList    *kbType_prop_subList={ibus_prop_list_new()};

    public IBusProperty    *kbType_prop={
        ibus_property_new(
		"chewing_kbType_prop",PROP_TYPE_MENU, 
		SELF_GET_CLASS(self)->kbType_prop_label,
                PKGDATADIR "/icons/input-keyboard.png",
		NULL, TRUE, FALSE, PROP_STATE_UNCHECKED, 
		self->kbType_prop_subList);
    };

    public IBusPropList   *prop_list={ibus_prop_list_new()};

    public IBusConfig *config=NULL;

    classwide GConfClient *gConfClient={gconf_client_get_default ()};
    classwide IBusText *kbType_prop_label={ibus_text_new_from_static_string(_("KbType"))};

    classwide IBusText *chieng_prop_label_chi={ibus_text_new_from_static_string(_("Chi"))};
    classwide IBusText *chieng_prop_label_eng={ibus_text_new_from_static_string(_("Eng"))};

    classwide IBusText *alnumSize_prop_label_full={ibus_text_new_from_static_string(_("Full"))};
    classwide IBusText *alnumSize_prop_label_half={ibus_text_new_from_static_string(_("Half"))};

    classwide IBusText *settings_prop_label={ibus_text_new_from_static_string(_("Settings"))};

    classwide IBusText **kbType_prop_labels={kbTypes_to_iBusTexts()};



    init (self) {
	GError *err=NULL;
          /* initialize the object here */
	G_DEBUG_MSG("*** init 1");

	chewing_Init("/usr/share/chewing","/tmp");

	self->context=chewing_new();

	self_context_load_parameters(self);

        chewing_set_ChiEngMode(self->context,CHINESE_MODE);

	/* set kbtype property */
	IBusProperty *prop;
	ChewingKbType kbType;
	for(kbType=0;kbType_ids[kbType]!=NULL;kbType++){
	    prop=ibus_property_new(kbType_ids[kbType],PROP_TYPE_RADIO, 
		    SELF_GET_CLASS(self)->kbType_prop_labels[kbType],
		    NULL, NULL, TRUE, 
		    TRUE, 
		    (kbType==0)? PROP_STATE_CHECKED :PROP_STATE_UNCHECKED, NULL);
	    ibus_prop_list_append(self->kbType_prop_subList,prop);
	}


	/* init properties */
	ibus_prop_list_append(self->prop_list,self->chieng_prop);
	ibus_prop_list_append(self->prop_list,self->alnumSize_prop);
	ibus_prop_list_append(self->prop_list,self->settings_prop);
	ibus_prop_list_append(self->prop_list,self->kbType_prop);

	ibus_lookup_table_clear(self->table);
    }

    private void context_load_parameters(self){
	int i;
	gchar key[200];
	GError *err=NULL;
	for (i=0; parameters[i].type!=GCONF_VALUE_INVALID;i++){
	    g_strlcpy(key,GCONF_KEY_PREFIX,200);
	    g_strlcat(key,parameters[i].key,200);
	    if (strcmp(parameters[i].key,"KBType")==0){
		gchar *kbType_str=gconf_client_get_string(SELF_GET_CLASS(self)->gConfClient, key, &err);
		ChewingKbType kbType;
		if (err){
		    staticString=TRUE;
		    g_warning("Warning: cannot load key %s because %s %s %s",
			    key,
			    err->message,
			    _("Use default value:"),
			    parameters[i].defaultValue);
		    g_error_free (err);
		    kbType=kbType_id_get_index(parameters[i].defaultValue);
		}else{
		    kbType=kbType_id_get_index(kbType_str);
		    g_free(kbType_str);
		}
		parameters[i].func(self->context,kbType);
	    }else if (strcmp(parameters[i].key,"selKeys")==0){
		gchar *selKeys_str=gconf_client_get_string(SELF_GET_CLASS(self)->gConfClient, key, &err);
		gboolean staticString=FALSE;
		int len;
		if (err){
		    g_warning("Warning: cannot load key %s because %s %s %s",
			    key,
			    err->message,
			    _("Use default value:"),
			    parameters[i].defaultValue);
		    g_error_free (err);
		    selKeys_str=parameters[i].defaultValue;
		    staticString=TRUE;
		}
		int len=strlen(selKeys_str);
		int *selKeys=g_new(int, len);
		int j;
		for (j=0;j<len;j++){
		    selKeys[j]=(int) selKeys_str[j];
		}
		chewing_set_selKey(self->context, selKeys,len);
		if (!staticString){
		    g_free(selKeys_str);
		}
	    }else if (parameters[i].type==GCONF_VALUE_BOOL){
	    }else if (parameters[i].type==GCONF_VALUE_INT){
	    }
	}

    }

    protected gboolean commit(self){
	/* commit string */
	gunichar *text=NULL;
	IBusText *iText=NULL;
	glong item_written;

	if (chewing_commit_Check(self->context)){
	    gchar *commit_string=chewing_commit_String(self->context);
	    text=g_utf8_to_ucs4_fast(commit_string,-1, &item_written);
	    iText=ibus_text_new_from_ucs4(text);
	    ibus_engine_commit_text(IBUS_ENGINE(self),iText);
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	    g_free(text);
	    g_free(commit_string);
	    g_object_unref(iText);
	}
	self_refresh_preedit(self);

	/* Update lookup table */
	ibus_lookup_table_clear(self->table);
	int choicePerPage=chewing_cand_ChoicePerPage(self->context);
	int i=0;
	char *candidate=NULL;
	iText=NULL;

	if (chewing_cand_TotalChoice(self->context) >0){
	    chewing_cand_Enumerate(self->context);
	    for(i=0;i<choicePerPage;i++){
		if (chewing_cand_hasNext(self->context)){
		    candidate=chewing_cand_String(self->context);
		    iText=ibus_text_new_from_string (candidate);
		    ibus_lookup_table_append_candidate(self->table,iText);
		    g_free(candidate);
		    g_object_unref (iText);
		}else{
		    break;
		}
	    }
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,TRUE);
	    ibus_engine_show_lookup_table(IBUS_ENGINE(self));
	}else{
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	}

	/* update aux string */
	gchar *aux_string=chewing_aux_String(self->context);
	text=g_utf8_to_ucs4_fast(aux_string,-1,&item_written);
	if (item_written>0){
	    iText=ibus_text_new_from_ucs4 (text);
	    ibus_engine_update_auxiliary_text(IBUS_ENGINE(self),iText,TRUE);
	    g_object_unref (iText);
	    ibus_engine_show_auxiliary_text(IBUS_ENGINE(self));
	}else{
	    ibus_engine_hide_auxiliary_text(IBUS_ENGINE(self));
	}

	g_free(aux_string);
	g_free(text);

	if (chewing_keystroke_CheckAbsorb(self->context))
	    return TRUE;
	if (chewing_keystroke_CheckIgnore(self->context))
	    return FALSE;
	return TRUE;
    }

    protected void refresh_preedit(self){
        glong zhuyin_item_written, item_written;
        gunichar *preeditBuf=preedit_string_make(self->context, &zhuyin_item_written, &item_written);
        IBusText *iText=ibus_text_new_from_ucs4(preeditBuf);
	int chiSymbolCursor = chewing_cursor_Current(self->context);
        ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_FOREGROUND, 0x00ffffff, 
                chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);
        ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_BACKGROUND, 0x00000000,
                chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);
        ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_UNDERLINE, IBUS_ATTR_UNDERLINE_SINGLE,
                0, -1);
	ibus_engine_update_preedit_text (IBUS_ENGINE(self),iText, chiSymbolCursor, TRUE);
        g_object_unref (iText);
    }


    protected void refresh_property(self,const gchar  *prop_name){
	G_DEBUG_MSG("*** refresh_property(-, %s) 1",prop_name);
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    if (chewing_get_ChiEngMode(self->context)){
		/* Chinese  */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_chi);
	    }else{
		/* English */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_eng);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->chieng_prop);
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    if (chewing_get_ShapeMode(self->context)){
		/* Full-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_full);
	    }else{
		/* Half-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_half);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->alnumSize_prop);
	}else if (strcmp(prop_name,"chewing_settings_prop")==0){
	    G_DEBUG_MSG("*** refresh_property(-, %s) 2, self->settings_prop->state=%u kbType->visible=%u ",
		    prop_name, self->settings_prop->state, self->kbType_prop->visible);
	    if (self->showSetting){
		self->settings_prop->state=PROP_STATE_CHECKED;
	    }else{
		self->settings_prop->state=PROP_STATE_UNCHECKED;
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->settings_prop);
	}else if (kbType_id_get_index(prop_name)>=0){
	    ChewingKbType kbType;
	    ChewingKbType kbType_now=chewing_get_KBType(self->context);
	    for(kbType=0;kbType_ids[kbType]!=NULL;kbType++){
		IBusProperty *prop=ibus_prop_list_get(self->kbType_prop_subList,kbType);
		prop->state=(kbType==kbType_now)? PROP_STATE_CHECKED: PROP_STATE_UNCHECKED;
		ibus_engine_update_property(IBUS_ENGINE(self),prop);
	    }
	}
    }


    /**
     * refresh_prop_lis:
     * @self: this instances.
     *
     * Refresh the property list (language bar).
     */
    public void refresh_property_list(self){
	/* Need this line to restore kbtype */
	self_refresh_property(self,kbType_ids[chewing_get_KBType(self->context)]);
	ibus_engine_register_properties(IBUS_ENGINE(self),self->prop_list);
    }

    /**
     * save_kbType:
     * @self: this instances.
     * @kbType: kbType to be set.
     * @returns: TRUE if successful, FALSE otherwise.
     *
     * Set and save the kbtype setting.
     */
    public gboolean save_kbType(self, Chewing:KbType kbType){
	if (kbType==CHEWING_KBTYPE_INVALID)
	    return FALSE;
	GValue kbTypeValue={0};
	g_value_init(&kbTypeValue,G_TYPE_STRING);
	g_value_set_static_string (&kbTypeValue,kbType_ids[kbType]);
	return ibus_config_set_value (self->config,"engine/Chewing","KbType",&kbTypeValue);
    }

    private IBusProperty* get_iBusProperty(self, const gchar *prop_name){
	ChewingKbType kbType;
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    return self->chieng_prop;
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    return self->alnumSize_prop;
	}else if (strcmp(prop_name,"chewing_settings_prop")==0){
	    return self->settings_prop;
	}else if (strcmp(prop_name,"chewing_kbType_prop")==0){
	    return self->kbType_prop;
	}else if ((kbType=kbType_id_get_index(prop_name))>=0){
	    return ibus_prop_list_get(self->kbType_prop_subList,kbType);
	}
	return NULL;
    }




    /*============================================
     * Overridden Parent (IBusEngine) methods
     */

    override (IBus:Engine) void
    reset(IBus:Engine *self){
	G_DEBUG_MSG("*** reset 1");
	Self *selfObj=SELF(self);
	ibus_lookup_table_clear(selfObj->table);
	chewing_Reset(selfObj->context);
	ibus_engine_hide_auxiliary_text(IBUS_ENGINE(self));
	self_commit(selfObj);
    }

    override (IBus:Engine) gboolean
    process_key_event(IBus:Engine *self, guint  keyval,  guint  modifiers){
	Self *selfObj=SELF(self);
	if (modifiers & IBUS_RELEASE_MASK){
	    G_DEBUG_MSG("*** process_key_event(-, %u(%c), %u) ...ignored",keyval, keyval, modifiers);
	    return FALSE;
	}
	G_DEBUG_MSG("*** process_key_event(-, %u(%c), %u) ... proceed.",keyval, keyval, modifiers);
	guint state= modifiers & (IBUS_SHIFT_MASK | IBUS_CONTROL_MASK | IBUS_MOD1_MASK);
	if (state==0){
	    switch (keyval){
		case IBUS_Return:
		case IBUS_KP_Enter:
		    chewing_handle_Enter(selfObj->context);
		    break;
		case IBUS_Escape:
		    chewing_handle_Esc(selfObj->context);
		    break;
		case IBUS_BackSpace:
		    chewing_handle_Backspace(selfObj->context);
		    break;
		case IBUS_Delete:
		case IBUS_KP_Delete:
		    chewing_handle_Del(selfObj->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_Space(selfObj->context);
		    break;
		case IBUS_Page_Up:
		case IBUS_KP_Page_Up:
		    IBUS_ENGINE_GET_CLASS(self)->page_up(self);
		    break;
		case IBUS_Page_Down:
		case IBUS_KP_Page_Down:
		    IBUS_ENGINE_GET_CLASS(self)->page_down(self);
		    break;
		case IBUS_Up:
		case IBUS_KP_Up:
		    IBUS_ENGINE_GET_CLASS(self)->cursor_up(self);
		    break;
		case IBUS_Down:
		case IBUS_KP_Down:
		    IBUS_ENGINE_GET_CLASS(self)->cursor_down(self);
		    break;
		case IBUS_Left:
		case IBUS_KP_Left:
		    chewing_handle_Left(selfObj->context);
		    break;
		case IBUS_Right:
		case IBUS_KP_Right:
		    chewing_handle_Left(selfObj->context);
		    break;
		case IBUS_Home:
		case IBUS_KP_Home:
		    chewing_handle_Home(selfObj->context);
		    break;
		case IBUS_End:
		case IBUS_KP_End:
		    chewing_handle_End(selfObj->context);
		    break;
		case IBUS_Tab:
		    chewing_handle_Tab(selfObj->context);
		    break;
		case IBUS_Caps_Lock:
		    chewing_handle_Capslock(selfObj->context);
		    self_refresh_property(selfObj,"chewing_chieng_prop");
		    break;
		default:
		    chewing_handle_Default(selfObj->context,keyval);
		    break;
	    }
	}else if (state==IBUS_SHIFT_MASK){
	    switch(keyval){
		case IBUS_Shift_L:
		    chewing_handle_ShiftLeft(selfObj->context);
		    break;
		case IBUS_Shift_R:
		    chewing_handle_ShiftRight(selfObj->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_ShiftSpace(selfObj->context);
		    chewing_set_ShapeMode(selfObj->context, !chewing_get_ShapeMode(selfObj->context));
		    self_refresh_property(selfObj,"chewing_alnumSize_prop");
		    break;
		default:
		    chewing_handle_Default(selfObj->context,keyval);
		    break;
	    }
	}else if (state==IBUS_CONTROL_MASK){
	    if (keyval>=IBUS_0 && keyval<=IBUS_9){
		chewing_handle_CtrlNum(selfObj->context,keyval);
	    }else if (keyval==IBUS_v || keyval==IBUS_V){
		chewing_handle_Right(selfObj->context);
	    }else{
		return FALSE;
	    }

	}else{
	    return FALSE;
	}
	return self_commit(selfObj);
    }


    override (IBus:Engine) void 
    page_up(IBus:Engine *self){
        Self *selfObj=SELF(self);
	chewing_handle_PageUp(selfObj->context);
	self_commit(selfObj);
    }


    override (IBus:Engine) void
    page_down(IBus:Engine *self){
        Self *selfObj=SELF(self);
	chewing_handle_PageDown(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    cursor_up(IBus:Engine *self){
        Self *selfObj=SELF(self);
	chewing_handle_Up(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    cursor_down(IBus:Engine *self){
	Self *selfObj=SELF(self);
	chewing_handle_Down(selfObj->context);
	self_commit(selfObj);
    }

    override (IBus:Engine) void
    enable(IBus:Engine  *self){
	Self *selfObj=SELF(self);
	G_DEBUG_MSG("*** enable 1");

	/* connections_list is not avail in init, so we put it here */
	GList  *connections_list=ibus_service_get_connections(IBUS_SERVICE(self));
	g_assert(connections_list);
	g_assert(connections_list->data);
	if (!selfObj->config){
	    IBusConnection *iConnection=(IBusConnection *) connections_list->data;
	    selfObj->config=ibus_config_new(iConnection);
	}

	/* Load/Set kbType */
	ChewingKbType kbType_set=0;
        GValue kbTypeValue={0};
        g_value_init(&kbTypeValue,G_TYPE_STRING);
        if (ibus_config_get_value (selfObj->config,"engine/Chewing","KbType",&kbTypeValue)){
            /* Config exists, loading */
            kbType_set=kbType_id_get_index(g_value_get_string(&kbTypeValue));
        }else{
             /* Config does not exist, initialing  */
	    kbType_set=CHEWING_KBTYPE_DEFAULT;
	    self_save_kbType(selfObj, kbType_set);
        }
	G_DEBUG_MSG("*** enable(): kbType=%d(%s)",kbType_set,kbType_ids[kbType_set]);

	ChewingKbType kbType_curr=chewing_get_KBType(selfObj->context);
	if (kbType_curr!=kbType_set){
	    chewing_set_KBType(selfObj->context,kbType_set);
	    self_refresh_property(selfObj,kbType_ids[kbType_set]);
	}
    }

    override (IBus:Engine) void
    disable(IBus:Engine  *self){
	G_DEBUG_MSG("*** disable 1");
    }

    override (IBus:Engine) void
    focus_in(IBus:Engine *self){
	G_DEBUG_MSG("*** focus_in 1");
	Self *selfObj=SELF(self);

	self_refresh_property_list(selfObj);
        self_refresh_preedit(selfObj);
    }

    override (IBus:Engine) void
    focus_out(IBus:Engine *self){
	G_DEBUG_MSG("*** focus_out 1");
	;
    }

    override (IBus:Engine) void
    property_activate(IBus:Engine *self, const gchar  *prop_name, guint  prop_state){
	G_DEBUG_MSG("*** property_activate(-, %s, %u) 1", prop_name, prop_state);
	Self *selfObj=SELF(self);
	ChewingKbType kbType;
	gboolean needRefresh=TRUE;

	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    /* Toggle Chinese <-> English */
	    chewing_set_ChiEngMode(selfObj->context, !chewing_get_ChiEngMode(selfObj->context));
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    /* Toggle Full <-> Half */
	    chewing_set_ShapeMode(selfObj->context, !chewing_get_ShapeMode(selfObj->context));
	}else if (strcmp(prop_name,"chewing_settings_prop")==0){
	    G_DEBUG_MSG("*** property_activate(-, %s, %u) 2 ",prop_name, prop_state);
	    if (prop_state==PROP_STATE_CHECKED){
		selfObj->showSetting=TRUE;
		IBUS_ENGINE_GET_CLASS(self)->property_show(self,"chewing_kbType_prop");
	    }else{
		selfObj->showSetting=FALSE;
		IBUS_ENGINE_GET_CLASS(self)->property_hide(self,"chewing_kbType_prop");
	    }
	}else if ((kbType=kbType_id_get_index(prop_name))>=0){
	    if (prop_state==PROP_STATE_CHECKED){
		if (chewing_set_KBType(selfObj->context,kbType)){
		    /* Unsuccessfully, set to default */
		    kbType=CHEWING_KBTYPE_DEFAULT;
		    chewing_set_KBType(selfObj->context,kbType);
		}
		self_save_kbType(selfObj, kbType);
	    }
  	    needRefresh=FALSE;
	}
	if (needRefresh)
	    self_refresh_property(selfObj,prop_name);
    }

    override (IBus:Engine) void
    property_show(IBus:Engine *self, const gchar  *prop_name){
	G_DEBUG_MSG("*** property_show 1");
	Self *selfObj=SELF(self);
	IBusProperty *prop=self_get_iBusProperty(selfObj, prop_name);
	ibus_property_set_visible(prop,TRUE);
	ibus_engine_update_property(self,prop);
	self_refresh_property_list(selfObj);
    }

    override (IBus:Engine) void
    property_hide(IBus:Engine *self, const gchar  *prop_name){
	G_DEBUG_MSG("*** property_hide 1");
	Self *selfObj=SELF(self);
	IBusProperty *prop=self_get_iBusProperty(selfObj, prop_name);
	ibus_property_set_visible(prop,FALSE);
	ibus_engine_update_property(self,prop);
	self_refresh_property_list(selfObj);
    }
}
