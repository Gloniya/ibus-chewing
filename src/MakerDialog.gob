requires 2.0.0

%alltop{
/*
 * Copyright © 2009  Red Hat, Inc. All rights reserved.
 * Copyright © 2009  Ding-Yi Chen <dchen at redhat.com>
 *
 * This file is part of the ibus-chewing Project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */ 
#include <stdlib.h>
#include <gtk/gtk.h>
#include <glib/gi18n.h>

%}

%headertop{
#ifndef MAKER_DIALOG_H_
#define MAKER_DIALOG_H_
typedef void (*AttributeSettingFunc)(gpointer attribute, gpointer value);
typedef gpointer (*AttributeGettingFunc)(gpointer attribute);

#define STRING_BUFFER_SIZE_DEFAULT 1000


typedef struct{
    GType valueType;
    gchar key[30];
    gchar pageName[50];
    gchar label[200];
    gchar *defaultValue;
    gchar **validValues;

    gint min;
    gint max;
    AttributeSettingFunc *setFunc;
    AttributeGettingFunc *getFunc;
} AttributeSpec;

#ifndef WIDGET_ID_PREFIX
#define WIDGET_ID_PREFIX "+"
#endif
%}


%{

gboolean maker_dialog_delete_event(GtkWidget *self, GdkEvent  *event,  gpointer   data ){
    /* If you return FALSE in the "delete_event" signal handler,
     * GTK will emit the "destroy" signal. Returning TRUE means
     * you don't want the window to be destroyed.
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs. */

    GtkResponseType response=*((GtkResponseType *) data);
    switch(response){
	case GTK_RESPONSE_DELETE_EVENT:
	case GTK_RESPONSE_CANCEL:
	case GTK_RESPONSE_OK:
	default:
	    break;
    }


    g_print ("delete event occurred\n");

    /* Change TRUE to FALSE and the main window will be destroyed with
     * a "delete_event". */

    return FALSE;
}


static void  ptrArray_free_deep_callback(gpointer data, gpointer user_data){
    g_free(data);
}

static gchar *widget_get_id(gchar *buffer, gint buffer_size, 
	const gchar *widget_label, const gchar *widget_type){
    g_snprintf(buffer,buffer_size,"%s%s_%s",
	    WIDGET_ID_PREFIX, widget_label, widget_type); 
    return buffer;
}


%}


class Maker:Dialog from Gtk:Dialog{
    public gboolean vbox_homogeneous=TRUE;
    public gint hbox_spacing=2;
    public gint vbox_spacing=2;
    public GtkWidget *dialog_notebook=NULL;

    private GHashTable *widgetTable={g_hash_table_new_full(g_str_hash,g_str_equal,NULL,NULL)};
    private GStringChunk *widgetIds={g_string_chunk_new(STRING_BUFFER_SIZE_DEFAULT)};

    public GPtrArray *settingParameters={g_ptr_array_new()}
    destroy{ 
	if (VAR) {
	    g_ptr_array_foreach(VAR,ptrArray_free_deep_callback, NULL);
	    g_ptr_array_free(VAR,TRUE);
	}
    };

    private GPtrArray *settingWidgets={g_ptr_array_new()}
    destroy{
	if (VAR) {
	    g_ptr_array_foreach(VAR,ptrArray_free_deep_callback, NULL);
	    g_ptr_array_free(VAR,TRUE);
	}
    };

    init(self){
    }

    public GObject *new (void) {
	  Self *self = GET_NEW;
	  return G_OBJECT (self);
    }

    public GObject *new_full (const gchar *title, 
	    int notebook_pages,  const gchar **notebook_page_labels,
	    int button_num, const gchar **button_labels, GtkResponseType *button_responses) {
	Self *self = GET_NEW;
	GtkDialog *dialog=GTK_DIALOG(self);
	gtk_window_set_title(GTK_WINDOW(dialog),title);
	gtk_window_set_destroy_with_parent (GTK_WINDOW(dialog), TRUE);
	gtk_window_set_type_hint (GTK_WINDOW(dialog), GDK_WINDOW_TYPE_HINT_DIALOG);

	int i;
	for(i=0;i<button_num;i++){
	    GtkWidget *button=gtk_dialog_add_button(dialog,button_labels[i],button_responses[i]);
	    self_widget_register(self, button, button_labels[i], "button");
	}

	GtkWidget *dialog_vbox = GTK_DIALOG(dialog)->vbox;
	gtk_widget_show (dialog_vbox);

	if (notebook_pages>0){
	    self->dialog_notebook = gtk_notebook_new();
	    gtk_widget_show (self->dialog_notebook);
	    gtk_box_pack_start (GTK_BOX(dialog_vbox), self->dialog_notebook, TRUE, TRUE, 0);
	    for (i=0;i<notebook_pages;i++){
		GtkWidget *label=gtk_label_new(notebook_page_labels[i]);
		self_widget_register(self, label, notebook_page_labels[i], "label");
		gtk_widget_show(label);

		GtkWidget *vbox=gtk_vbox_new(self->vbox_homogeneous,self->vbox_spacing);
		self_widget_register(self, vbox, notebook_page_labels[i], "vbox");
		gtk_widget_show(vbox);
		gtk_notebook_append_page (GTK_NOTEBOOK(self->dialog_notebook), vbox,label);
	    }
	}
	return G_OBJECT(self);
    }

    public gboolean add_attribute(self, AttributeSpec *aSpec){
	GtkWidget *vbox=self_get_base_vbox(self, aSpec->pageName);
	g_assert(vbox);

	GtkWidget *hbox=gtk_hbox_new(FALSE,self->hbox_spacing);
	self_widget_register(self, hbox, aSpec->key, "hbox");
	GtkWidget *label=gtk_label_new(aSpec->label);
	gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_LEFT);
	self_widget_register(self, label, aSpec->label, "label");
	gtk_widget_show(label);	
	gtk_box_pack_start (GTK_BOX(hbox), label, TRUE, FALSE, 0);

	GtkWidget *widget=NULL;
        GtkAdjustment *gAdjust=NULL;

	switch(aSpec->valueType){
	    case G_TYPE_BOOLEAN:
		widget = gtk_check_button_new();
		self_widget_register(self, widget, aSpec->key, "check");
		if (aSpec->setFunc){
		    g_signal_connect (widget, "toggled",
			    G_CALLBACK (aSpec->setFunc), aSpec->key);
		}
		break;
	    case G_TYPE_UINT:
	    case G_TYPE_INT:
		 gAdjust = (GtkAdjustment *)gtk_adjustment_new (atoi(aSpec->defaultValue), 
			     aSpec->min, aSpec->max, 1.0, 5.0, 5.0);
		 widget = gtk_spin_button_new (gAdjust, 1.0, 0);
		 self_widget_register(self, widget, aSpec->key, "spinner");
		 if (aSpec->setFunc){
		     g_signal_connect (widget, "value-changed",
			     G_CALLBACK (aSpec->setFunc), aSpec->key);
		 }
		 break;
	    case G_TYPE_STRING:
		if (aSpec->validValues){
		    widget=gtk_combo_box_new_text ();
		    int i,default_i=-1;
		    for(i=0;aSpec->validValues[i]!=NULL;i++){
			if (aSpec->defaultValue && strcmp(aSpec->defaultValue,aSpec->validValues[i])==0 ){
			    default_i=i;
			}
			gtk_combo_box_append_text(GTK_COMBO_BOX(widget),aSpec->validValues[i]);
		    }
		    gtk_combo_box_set_active(GTK_COMBO_BOX(widget),default_i);
		}else{
		    widget=gtk_entry_new();
		    if (aSpec->max>=0){
			gtk_entry_set_max_length(GTK_ENTRY(widget),aSpec->max);
		    }
		    if (aSpec->defaultValue){
			gtk_entry_set_text(GTK_ENTRY(widget),aSpec->defaultValue);
		    }
		}
		break;
	    default:
		break;
	}
	if (!widget){
	    return FALSE;
	}

	gtk_widget_show(widget);	
	gtk_box_pack_start (GTK_BOX(hbox), widget, FALSE, FALSE, 0);
	gtk_widget_show(hbox);
	gtk_box_pack_start (GTK_BOX(vbox), hbox, TRUE, TRUE, 0);
	return TRUE;
    }

    public void close(self, gboolean restore_parameter){
	if (restore_parameter){

	}


    }

    protected GtkWidget *get_base_vbox(self, const gchar *notebook_page_label){
	gchar buf[STRING_BUFFER_SIZE_DEFAULT];
	GtkWidget *ret;
	if (notebook_page_label){
	    widget_get_id(buf, STRING_BUFFER_SIZE_DEFAULT, notebook_page_label, "vbox");
	    ret=self_widget_lookup(self, notebook_page_label, "vbox");
	}else{
	    ret=GTK_DIALOG(self)->vbox;
	}
	if (!ret){
	    ret=GTK_DIALOG(self)->vbox;
	}
	return ret;
    }

    public GtkWidget *widget_lookup(self, 
	    const gchar *widget_label, const gchar *widget_type){
	gchar buf[STRING_BUFFER_SIZE_DEFAULT];
	widget_get_id(buf, STRING_BUFFER_SIZE_DEFAULT, widget_label, widget_type);
	return (GtkWidget *) g_hash_table_lookup (self->_priv->widgetTable, buf);
    }

    private void widget_register(self, GtkWidget *widget, 
	    const gchar *widget_label, const gchar *widget_type){
	gchar buf[STRING_BUFFER_SIZE_DEFAULT];
	widget_get_id(buf, STRING_BUFFER_SIZE_DEFAULT, widget_label, widget_type);
	gchar *chunk_ret=g_string_chunk_insert(self->_priv->widgetIds,buf);
	g_hash_table_insert(self->_priv->widgetTable, chunk_ret, widget);

    }


}

%headertop{
#endif /* MAKER_DIALOG_H_ */
%}

