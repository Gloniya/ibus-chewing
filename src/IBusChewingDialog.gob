requires 2.0.0

%alltop{
/*
 * Copyright © 2009  Red Hat, Inc. All rights reserved.
 * Copyright © 2009  Ding-Yi Chen <dchen at redhat.com>
 *
 * This file is part of the ibus-chewing Project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */ 
#include <gtk/gtk.h>
#include <glib/gi18n.h>

%}

%{
const gchar *page_labels[]={
   N_("Preference"),
   N_("Look & Feel"),
   N_("Keyboard"),
   NULL
};

const gchar *button_labels[]={
    GTK_STOCK_APPLY,
    GTK_STOCK_CANCEL,
    GTK_STOCK_OK,
    NULL
};

const gint button_responses[]={
    GTK_RESPONSE_APPLY,
    GTK_RESPONSE_CANCEL,
    GTK_RESPONSE_OK
};

static void  ptrArray_free_deep_callback(gpointer data, gpointer user_data){
    g_free(data);
}
%}


class IBus:Chewing:Dialog from Gtk:Dialog{
    public gboolean vbox_homogeneous=TRUE;
    public gint vbox_spacing=2;
    public GtkWidget *dialog_notebook=NULL;

    public GPtrArray *settingParameters={g_ptr_array_new()}
    destroy{ 
	if (VAR) {
	    g_ptr_array_foreach(VAR,ptrArray_free_deep_callback, NULL);
	    g_ptr_array_free(VAR,TRUE);
	}
    };

    private GPtrArray *settingWidgets={g_ptr_array_new()}
    destroy{
	if (VAR) {
	    g_ptr_array_foreach(VAR,ptrArray_free_deep_callback, NULL);
	    g_ptr_array_free(VAR,TRUE);
	}
    };

    init(self){
    }

    public GObject *new (void) {
	  Self *self = GET_NEW;
	  return G_OBJECT (self);
    }

    public GObject *new_full (const gchar *title, 
	    int notebook_pages,  const gchar **notebook_page_labels,
	    int button_num, const gchar **button_labels, const int *button_responses) {
	Self *self = GET_NEW;
	GtkDialog *dialog=GTK_DIALOG(self);
	gtk_window_set_title(GTK_WINDOW(dialog),title);
	gtk_window_set_destroy_with_parent (GTK_WINDOW(dialog), TRUE);
	gtk_window_set_type_hint (GTK_WINDOW(dialog), GDK_WINDOW_TYPE_HINT_DIALOG);

	int i;
	for(i=0;i<button_num;i++){
	    gtk_dialog_add_button(dialog,button_labels[i],button_responses[i]);
	}

	if (notebook_pages>0){
	    GtkWidget *dialog_vbox = GTK_DIALOG(dialog)->vbox;
	    gtk_widget_show (dialog_vbox);

	    self->dialog_notebook = gtk_notebook_new();
	    gtk_widget_show (self->dialog_notebook);
	    gtk_box_pack_start (GTK_BOX(dialog_vbox), self->dialog_notebook, TRUE, TRUE, 0);
	    for (i=0;i<notebook_pages;i++){
		GtkWidget *label=gtk_label_new(notebook_page_labels[i]);
		GtkWidget *vbox=gtk_vbox_new(self->vbox_homogeneous,self->vbox_spacing);
		gtk_widget_show(label);
		gtk_widget_show(vbox);
		gtk_notebook_append_page (GTK_NOTEBOOK(self->dialog_notebook), vbox,label);
	    }
	}
	return G_OBJECT(self);
    }

    public GObject *new_default(void ){
	GObject *ret=self_new_full("_(Setting)",3,page_labels,3,button_labels,button_responses);
	return G_OBJECT (ret);
    }

}

